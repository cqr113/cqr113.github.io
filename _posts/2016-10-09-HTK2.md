---
layout: post
title:  HTK解码代码分析2
date:   2016-10-09 12:20:00 +0800
categories: 语音识别
tag: HTK
---

* content
{:toc}

   HTK解码总体流程：
-----------------------------------------
首先在HVite.C的main函数中调用相应库的函数。

    HVite_main()
    ｛
      解析HVite命令行；
      Initialise();
      net = ExpandWordNet(&netHeap,wdNet,&vocab,&hset);
      for(所有需要识别的MFCC文件）
    ｛
      ProcessFile(datFN,net,n++,genBeam,FALSE);
      ｝
      释放内存资源；
      
    ｝

   Initialise();

    功能说明：从字典文件ditionary中解析字典信息并初始化相应的字典结构体Vocab。从网格文件net中解析网络信息并
    初始化相应的网格结构体Lattice。从HMM文件中解析HMM模型信息并初始化相应的模型结构体HMMSet。 

   net = ExpandWordNet(&netHeap,wdNet,&vocab,&hset);

    功能说明：整合字典，HMM模型和网格信息，将它们扩展为可用于识别的网络结构net。
 

   ProcessFile(datFN,net,n++,genBeam,FALSE);

    功能说明：解码MFCC文件，并保存解码的结果。
    输入说明：
    datFN是需要解码的MFCC文件指针，这个文件包含一帧一帧MFCC参数的观察序列。
    net是解码网络，这个网络包含了所有可能的识别路径。
    n表示要解码第几个MFCC文件（这说明HTK可以解很多MFCC文件）。
    genBeam是裁剪值。

   ProcessFile()的主要代码分析：
-----------------------------------------
    ProcessFile()
    ｛
   
    StartRecognitio(vri,net,lmScale,wordPen,prScale);

    SetPruningLevels(vri,maxActive,currGenBeam,wordBeam,nBeam,tmBeam);

    while(最后一帧观察序列!=ture)
    {   

    ReadAsBuffer(pbuf,&obs);
   
    ProcessObservation(vri,&obs,-1,xfInfo.inXForm);

    }


    lat=CompleteRecognition(vri,pbinfo.tgtSampRate/10000000.0,&ansHeap);

    trans=TranscriptionFromLattice(&ansHeap,lat,nTrans);

    LSave(lfn,trans,ofmt);
 
    ｝

   StartRecognitio(vri,net,lmScale,wordPen,prScale);

    功能说明：初始化解码环境。

   SetPruningLevels(vri,maxActive,currGenBeam,wordBeam,nBeam,tmBeam);

    功能说明：设置裁剪值。

   ReadAsBuffer(pbuf,&obs);

    功能说明：从MFCC文件中读取一帧观察序列。

   ProcessObservation(vri,&obs,-1,xfInfo.inXForm);

    功能说明：解码每一帧MFCC参数的观察序列。这个函数会被循环调用，直至到最后一帧观察序列。
    输入说明：
    vri是识别过程中保存信息的结构体。
    &obs是顺序读取的每一帧MFCC参数的观察序列。

lat=CompleteRecognition(vri,pbinfo.tgtSampRate/10000000.0,&ansHeap);

    功能说明：通过追溯令牌中保存的path信息，生成识别结果网格。

trans=TranscriptionFromLattice(&ansHeap,lat,nTrans);
    
    功能说明：把识别结果网格转换成脚本。

LSave(lfn,trans,ofmt);

    功能说明：把识别结果脚本保存到MLF文件中。

   ProcessObservation()的主要代码分析：
------------------------------------
  这个函数是HTK解码的核心。

  首先解释两个重要的概念。HTK的节点可分为HMM模型节点和单词节点，每个HMM模型节点都有一个后续的相应单词节点。比如bit=b ih t,bit是单词节点，b,ih和t都是HMM模型节点，b,ih和t都有后续的单词节点bit。HTK定义了两个特殊状态，就是entry state和exit state。这两个state并没有观察序列，但起着承上启下的作用。节点的entry state能够接收了最佳节点的最佳令牌，这样可以保证每个HMM模型节点计算概率的初始条件是一样的。节点的exit state的令牌概率表示整个节点的最佳输出概率。

  HTK采用了token pass令牌传递算法来实现语音识别。这个算法的根本思想还是基于viterbi维特比算法。它分成了两个步骤，第一步是内部令牌传递，用viterbi算法计算出每个HMM模型节点在当前时刻t每个状态的局部最佳概率，并传递给exit state。第二步是外部令牌传递。首先每个单词节点会把entry state的token令牌传递给exit state，同时创建当前时刻的path路径信息并保存在exit state的path链表中。接着节点会把exit state的令牌传递给概率比它小的后续节点entry state。注意，以后通过回溯path链表的成员项prev可以得出最佳单词节点序列，即识别结果。所以，这个path链表的成员项prev是不容易被更新的，只有新的单词出现时才会被更新。

  对于每个时刻的观察序列，ProcessObservation()都会计算每个HMM模型节点的exit state概率，并把取得最大概率值的HMM模型节点的token传递给后续节点。但这个传递不能立即反映新单词的出现。因为新出现单词的令牌概率不会立刻超越当前单词的令牌概率。随着多帧观察序列被计算，新出现单词的令牌概率会大于旧单词的令牌概率，这时新单词的信息会被插入到path链表的成员项prev中。
  


    ProcessObservation()
    ｛   

    /* 内部令牌传递 StepInst1(inst->node);*/

    for (识别路径上的所有节点Node[i]实例)
    ｛
    if(节点==HMM模型节点）
    {
    计算当前时刻观察序列obs对于HMM模型节点Node[i]的最大概率。
    计算HMM模型节点Node[i]实例的exit state概率。
    }
    else if(节点==单词节点） 
    ｛清除单词节点的entry state和exit state的概率值。｝
     ｝
 

     /* 外部令牌传递 StepInst2(inst->node);*/

    for (识别路径上的所有节点Node[i]实例)
      if (节点概率值小于裁剪值) {
         删除节点Node[i]实例。
      }
      else {
         if(节点==非空的单词节点） 
      {
     
     节点Node[i]实例的exit state的token=节点Node[i]实例的entry state的token（即将单词节点Node[i]实例的entry state的token令牌传递给exit state。）
     创建当前时刻的路径信息path。
     节点Node[i]实例->exit->token.path=path。
     Node[i]实例->exit->token.path->prev=Node[i]实例->state->token.path。（这条指令将新单词的path信息插入到path链表的成员项prev中。）
    }
     for(节点Node[i]实例的后继节点Node[j]）
    ｛
      if(节点Node[j]实例还没生成）
       创建节点Node[j]实例
      if(节点Node[j]实例的entry state概率值<节点Node[i]实例的exit state概率值)
        节点Node[j]实例的entry state的token=节点Node[i]实例的exit state的token。
     ｝
      }
     ｝

一个简单的yes-no识别例子：
------------------------------
任务语法限制如下：

     $WORD = YES | NO;   
    ( { SIL } < $WORD > { SIL } ) 

一共有三个HMM模型，分别是sil,yes和no。字典信息如下：

    YES [yes] yes 
    NO [no] no   
    SIL [sil] sil

用HParse命令，转换成网格信息如下（7个节点，12个连接）：

    N=7    L=12   
    I=0    W=SIL                 
    I=1    W=NO                  
    I=2    W=!NULL               
    I=3    W=YES                 
    I=4    W=SIL                 
    I=5    W=!NULL               
    I=6    W=!NULL               
    J=0     S=2    E=0    
    J=1     S=2    E=1    
    J=2     S=4    E=1    
    J=3     S=6    E=1    
    J=4     S=1    E=2    
    J=5     S=3    E=2    
    J=6     S=2    E=3    
    J=7     S=4    E=3    
    J=8     S=6    E=3    
    J=9     S=6    E=4    
    J=10    S=0    E=5    
    J=11    S=2    E=5  

ProcessObservation()生成的节点实例网络如下：

![](http://i.imgur.com/kJSuEzd.jpg)

小写的sil,yes和no是HMM模型节点，大写的SIL,YES,NO和NULL是单词节点。令牌传递过程如下：

    sil的令牌从entry state一直传递给exit state,接着sil的exit state令牌传递给SIL的entry state。SIL的令牌会传递给yes和no的entry state。接着yes的exit state令牌会传递给单词节点YES的entry state，no的exit state令牌会传递给单词节点NO的entry state。YES和NO会将entry state令牌传递给自身的exit state，接着YES和NO会将各自exit state令牌传递给NULL1,但NULL1只会接受概率值最大的令牌。注意，单词节点NULL不会创建路径信息path,它仅仅起过渡作用，把前继节点令牌传递给后继节点。最后，NULL1会将exit state令牌分别传给yes,no和sil。从这里可以看出，yes会接受SIL和NULL的令牌，no会接受SIL和NULL的令牌,然后看SIL和NULL哪个令牌大就会接受哪个。

假设现在要识别的MFCC文件内容是SIL-NO-YES-SIL，识别结果如下：

    "C:/HTK/htk/data/test/mfcc/yes_no_yes_0.rec"
     0 100000 s3 -156.115662 sil -3760.114014 SIL
     100000 4500000 s5 -3601.917969
     4500000 4600000 s2 -76.337799 sil -1485.466675 SIL
     4600000 6200000 s4 -1074.701172
     6200000 6600000 s5 -334.294281
     6600000 7400000 s2 -737.986572 no -2600.320801 NO
     7400000 8200000 s3 -684.429138
     8200000 8600000 s4 -340.492188
     8600000 9700000 s5 -837.412903
     9700000 11000000 s2 -924.753235 yes -7088.080566 YES
     11000000 12500000 s3 -1245.929077
     12500000 13500000 s4 -570.135193
     13500000 20000000 s5 -4347.263184
     20000000 21100000 s2 -877.634888 sil -2479.738770 SIL
     21100000 21900000 s3 -585.977783
     21900000 22200000 s4 -244.961655
     22200000 23300000 s5 -771.164551

现在看看HTK解码是如何工作的。

一开始，HTK会用viterbi算法分别计算sil,yes和no的HMM模型的令牌输出概率，这时sil的概率会最大。

随着时间的转移，新单词NO出现了。这时sil的令牌概率会慢慢
变小，no的令牌概率会慢慢变大。当no的令牌概率超越sil时，no的令牌会传递给NULL1。新单词NO(从第66帧开始）的path信息会被插入到path链表的成员项prev中。在单词YES出现之前，根据令牌传递的顺序，可以得出：

    节点no实例->exit->token.path.frame=66
    节点NO实例->entry->token.path.frame=66
    节点NO实例->exit->token.path.frame=当前帧数
    节点NO实例->exit->token.path->prev.frame=66
    节点NULL实例->exit->token.path.frame=当前帧数
    节点NULL实例->exit->token.path->prev.frame=66
    节点no实例->entry->token.path.frame=当前帧数
    节点no实例->entry->token.path->prev.frame=66
    节点yes实例->entry->token.path.frame=当前帧数
    节点yes实例->entry->token.path->prev.frame=66

当新单词YES(从第97帧开始）出现后，上面的节点yes实例->entry->token会从entry state一直传递到exit state。一旦
yes令牌概率大于no令牌概率，则有：

    节点yes实例->exit->token.path.frame=97
    节点yes实例->exit->token.path->prev.frame=66
    节点YES实例->entry->token.path.frame=97
    节点YES实例->entry->token.path->prev.frame=66
    节点YES实例->exit->token.path.frame=当前帧数
    节点YES实例->exit->token.path->prev.frame=97
    节点YES实例->exit->token.path->prev->prev.frame=66
    节点NULL实例->exit->token.path.frame=当前帧数
    节点NULL实例->exit->token.path->prev.frame=97
    节点NULL实例->exit->token.path->prev->prev.frame=66

看到了吗？prev增加了一个表项，保存了新单词YES的path信息。







