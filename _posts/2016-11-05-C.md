---
layout: post
title:  理解C
date:   2016-11-05 10:35:00 +0800
categories: C语言
tag: C语言
---

* content
{:toc}

   要理解C语言的某些语法必须要结合编译器和运行平台来思考。所有C指令都会转成平台相关的二进制代码,这个转换都是合乎计算机科学的逻辑，并非凭空想象。


     1.C语言中的float,double数据类型，转换成二进制代码，最终存放在计算机基本都是IEEE745格式。

     2.一维数组存放在计算机中，并非每个元素都有直接的地址。当定义数据a[n]，编译器会给数组分配首地址，存放这个地址的变量是a，即变量a的值是数组首地址。 当要读取a[i]这个元素时，编译器就会用a+i找到这个元素。

     3.定义静态二维数组a[n][m]时，编译器也只是给数组分配首地址。即定义一个指针变量*a，用来存放数组首地址。二维数组在物理上实际是按照一维数组的方式来存放，所以可以用a+i*m+j来读取元素a[i][j]。

     定义动态二维数组a[4][4]的方法如下：
      int **a;
      int i,n=4, m=4;
      a = (int**)malloc(sizeof(int*)*n);//为二维数组分配4行
      for (i = 0; i < n; ++i){//为每列分配4个大小空间
        a[i] = (int*)malloc(sizeof(int)*m);

     这样就产生了以下的内存结构：

     ![](http://i.imgur.com/YIOP1IT.jpg)
     
     a+i是存放数组第i行首地址的变量的地址，比如a+1=2010H。*(a+i)即数组第i行的首地址，比如*(a+1)=2378H。*(*(a+i)+j)可以读取到a[i][j]的值。

     现再看下静态数组a[4][4]的内存结构：
     
     ![](http://i.imgur.com/ic0xlED.jpg)


     很明显看出，少了中间指向行地址的指针。a+i是数组第i行的首地址，*(a+i)并非a[i][0]的值，而是延用了动态二维数组里面二重指针的概念，虚拟出指向行地址的指针，编译器会根据这个假设，*(a+i)也会被编译为数组第i行的首地址。

     4.定义char *a[n]时,编译器会定义指针**a,保存指针数组的首地址。a+i即数组第i个元素的地址，*(a+i)即第i个字符串的首地址。

     5.定义结构体
       srtuct a
       {
       int   n;
       short m;
       };
       struct a *p;
       当出现这个语句(p+i)->m时，编译器会计算它的地址
       p+(sizeof(int)+sizeof(short))*i+sizeof(int)并转成平台相关的二进制代码。
 


以下是网络看到的回帖，觉得很有道理，摘录一下：


计算机组成原理→DOS命令→汇编语言→C语言（不包括C++）、代码书写规范→数据结构、编译原理、操作系统→计算机网络、数据库原理、正则表达式→其它语言（包括C++）、架构……

对学习编程者的忠告：
多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！
眼过千遍不如手过一遍！
书看千行不如手敲一行！
手敲千行不如单步一行！
单步源代码千行不如单步Debug版对应汇编一行！
单步Debug版对应汇编千行不如单步Release版对应汇编一行！

单步类的实例“构造”或“复制”或“作为函数参数”或“作为函数返回值返回”或“参加各种运算”或“退出作用域”的语句对应的汇编代码几步后，就会来到该类的“构造函数”或“复制构造函数”或“运算符重载”或“析构函数”对应的C/C++源代码处。

VC调试时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
对VC来说，所谓‘调试时’就是编译连接通过以后，按F10或F11键单步执行一步以后的时候，或者在某行按F9设了断点后按F5执行停在该断点处的时候。
（Turbo C或Borland C用Turbo Debugger调试,Linux或Unix下用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）

想要从本质上理解C指针，必须学习汇编以及C和汇编的对应关系。
从汇编的角度理解和学习C语言的指针，原本看似复杂的东西就会变得非常简单！
指针即地址。“地址又是啥？”“只能从汇编语言和计算机组成原理的角度去解释了。”
但我又不得不承认：
 有那么些人喜欢或者适合用“先具体再抽象”的方法学习和理解复杂事物；
 而另一些人喜欢或者适合用“先抽象再具体”的方法学习和理解复杂事物。
而我本人属前者。

不要企图依赖输出指针相关表达式...的值【比如printf("%p\n",...);或者cout<<...】来理解指针的本质，
而要依赖调试时的反汇编窗口中的C/C++代码【比如void *p=(void *)(...);】及其对应汇编指令以及内存窗口中的内存地址和内存值来理解指针的本质。

这辈子不看内存地址和内存值；只画链表、指针示意图，画堆栈示意图，画各种示意图，甚至自己没画过而只看过书上的图……能从本质上理解指针、理解函数参数传递吗？本人深表怀疑！
这辈子不种麦不收麦不将麦粒拿去磨面；只吃馒头、吃面条、吃面包、……甚至从没看过别人怎么蒸馒头，压面条，烤面包，……能从本质上理解面粉、理解面食吗？本人深表怀疑！！

提醒：
“学习用汇编语言写程序”
和
“VC调试(TC或BC用TD调试)时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，这样过一遍不就啥都明白了吗。
（Linux或Unix下可以在用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）
想要从本质上理解C指针，必须学习C和汇编的对应关系。”
不是一回事！

不要迷信书、考题、老师、回帖；
要迷信CPU、编译器、调试器、运行结果。
并请结合“盲人摸太阳”和“驾船出海时一定只带一个指南针。”加以理解。
任何理论、权威、传说、真理、标准、解释、想象、知识……都比不上摆在眼前的事实！

有人说一套做一套，你相信他说的还是相信他做的？
其实严格来说这个世界上古往今来所有人都是说一套做一套，不是吗？

不要写连自己也预测不了结果的代码！

电脑内存或文件内容只是一个一维二进制字节数组及其对应的二进制地址；
人脑才将电脑内存或文件内容中的这个一维二进制字节数组及其对应的二进制地址的某些部分看成是整数、有符号数/无符号数、浮点数、复数、英文字母、阿拉伯数字、中文/韩文/法文……字符/字符串、汇编指令、函数、函数参数、堆、栈、数组、指针、数组指针、指针数组、数组的数组、指针的指针、二维数组、字符点阵、字符笔画的坐标、黑白二值图片、灰度图片、彩色图片、录音、视频、指纹信息、身份证信息……
    


