---
layout: post
title:  VC调试经验
date:   2016-11-19 16:30:00 +0800
categories: C语言
tag: C语言
---

* content
{:toc}

1.VC中是用补码的形式来存储整型数据。用补码的好处是CPU只需用加法器即可实现整数的加减法运算。具体分析有两点：

    一.[X+Y]补 = [X]补 + [Y]补

随便写一个计算式，16 + (-8) = ?
16的二进制表示是 00010000，所以用直觉表示法，加法就要写成：

　０００１００００

＋１０００１０００

－－－－－－－－－

　１００１１０００

可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。显然，这是错误的答案。也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法，因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。从电路上说，就是必须为加法运算做两种电路。
现在，再来看2的补码表示法。

　 ０００１００００

＋１１１１１０００

－－－－－－－－－

１００００１０００

可以看到，按照正常的加法规则，得到的结果是100001000。注意，这是一个9位的二进制数。我们已经假定这是一台8位机，因此最高的第9位是一个溢出位，会被自动舍去。所以，结果就变成了00001000，转成十进制正好是8，也就是16 + (-8) 的正确答案。这说明了，2的补码表示法可以将加法运算规则，扩展到整个整数集，从而用一套电路就可以实现全部整数的加法。


    二.[X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补

从上式可以看出，用补码可以将减法转化成加法运算。举一个例子：

4-（-3）=0100-1101=0100+0011=0111=7

  4 - 3 =0100-0011=0100+1101=0001=1

  -3-4  =1101-0100=1101+1100=1001=-7



可以看出，编译器只需把被减数做补码运算取反加一（不管被减数是正数还是负数），即可将减法转化成加法运算。

2.在VC中的整数运算，不管是signed还是unsigned,编译器都是以一样的方式做运算。举一个例子：

    short  bin3,bin4,bin5;
	unsigned short bin8,bin9,bin10;

    bin9=63000;
	bin10=10000;
	bin8=bin9-bin10;
	printf("bin8=%d,bin8在内存中的十六进制值=%x\n",bin8,*(unsigned short*)(&bin8));

	bin3=63000;
	bin4=10000;![](http://i.imgur.com/tic67Gx.png)
	bin5=bin3-bin4;
	printf("bin5=%d,bin5在内存中的十六进制值=%x\n",bin5,*(short*)(&bin5));

打印结果如下：

![](http://i.imgur.com/2n1v42b.png)


signed和unsigned这两种类型的整数相减的结果在内存中的值都是cf08。这说明编译器是以一样的方式做运算。下面这个也能看出来：

signed:  -3-1  =1101-0001=1101+1111=1100=-4

unsigned:13-1  =1101-0001=1100=12

3.VC做两个整数相加减运算时不会做超出最大值的溢出处理。

    short  bin3,bin4,bin5;
    bin3=23000;
	bin4=10000;
	bin5=bin3+bin4;

这个出来的结果不会卡在16bit signed能表示的最大值32767。结果是-32536。

4.补码的概念只存在整数中，浮点数float都是原码。我们在应用中，必须要明确知道数据是signed还是unsigned。

5.使用这个函数hSearch=FindFirstFile("txt\\*.txt",&fd); 必须设置如下：

![](http://i.imgur.com/U2TOucD.png)

否则编译器找不到txt\\*.txt，获取不了第一个文件句柄。

6.定义指针必须要给它赋地址值。

7.不能把未赋值的局部变量赋值给其它变量。








